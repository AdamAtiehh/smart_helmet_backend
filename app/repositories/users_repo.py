from __future__ import annotations
from datetime import datetime
from typing import Optional, Sequence

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.db_models import User


# -----------------------------
# CREATE / UPDATE (UPSERT)
# -----------------------------

# -----------------------------
# CREATE / UPDATE (UPSERT)
# -----------------------------
async def upsert_by_firebase_uid(
    db: AsyncSession,
    *,
    firebase_uid: str,
    display_name: Optional[str] = None,
    email: Optional[str] = None,
    phone_number: Optional[str] = None,
) -> User:
    """
    Find user by Firebase UID, or create if new.
    """
    res = await db.execute(select(User).where(User.firebase_uid == firebase_uid))
    user = res.scalar_one_or_none()

    if user is None:
        user = User(
            # user_id will be auto-generated by the model default
            firebase_uid=firebase_uid,
            display_name=display_name,
            email=email,
            phone_number=phone_number,
            created_at=datetime.utcnow(),
        )
        db.add(user)
    else:
        # Optional: Update profile info on login if changed
        needs_update = False
        if display_name and user.display_name != display_name:
            user.display_name = display_name
            needs_update = True
        if email and user.email != email:
            user.email = email
            needs_update = True
        if phone_number and user.phone_number != phone_number:
            user.phone_number = phone_number
            needs_update = True
        
        if needs_update:
            db.add(user)

    await db.commit()
    await db.refresh(user)
    return user


# -----------------------------
# FETCH (READ)
# -----------------------------
async def get_user(db: AsyncSession, user_id: str) -> Optional[User]:
    """Return one user by their internal user_id."""
    res = await db.execute(select(User).where(User.user_id == user_id))
    return res.scalar_one_or_none()


async def list_users(db: AsyncSession, limit: int = 100) -> Sequence[User]:
    """List latest registered users (for dashboard or debugging)."""
    res = await db.execute(
        select(User).order_by(User.created_at.desc()).limit(limit)
    )
    return tuple(res.scalars().all())


# --- New Methods for API ---

class UsersRepo:
    """
    Static wrapper class for better import usage in endpoints.
    """
    @staticmethod
    async def get_user(db: AsyncSession, user_id: str) -> Optional[User]:
        return await get_user(db, user_id)

    @staticmethod
    async def create_user(
        db: AsyncSession, 
        firebase_uid: str, 
        email: Optional[str] = None, 
        display_name: Optional[str] = None
    ) -> User:
        return await upsert_by_firebase_uid(db, firebase_uid=firebase_uid, email=email, display_name=display_name)

    @staticmethod
    async def update_user(
        db: AsyncSession, 
        firebase_uid: str, 
        email: Optional[str] = None, 
        display_name: Optional[str] = None,
        phone_number: Optional[str] = None

    ) -> User:
        return await upsert_by_firebase_uid(db, firebase_uid=firebase_uid, email=email, display_name=display_name, phone_number=phone_number)